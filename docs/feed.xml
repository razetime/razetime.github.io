<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://razetime.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://razetime.github.io/" rel="alternate" type="text/html" /><updated>2023-11-22T05:11:14+08:00</updated><id>https://razetime.github.io/feed.xml</id><title type="html">Razetime</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Exploring Z-order in BQN</title><link href="https://razetime.github.io/blog/2023/11/22/bqn-z-order.html" rel="alternate" type="text/html" title="Exploring Z-order in BQN" /><published>2023-11-22T00:00:00+08:00</published><updated>2023-11-22T00:00:00+08:00</updated><id>https://razetime.github.io/blog/2023/11/22/bqn-z-order</id><content type="html" xml:base="https://razetime.github.io/blog/2023/11/22/bqn-z-order.html"><![CDATA[<p><em>The code for this article can be found on
<a href="https://github.com/razetime/bqnforklift">Github</a>.</em></p>

<p>In my coursework for spatial databases, we came upon the z-order curve, a
space-filling curve that attempts to put multidimesional points into a
single-dimension space with minimal change to the distance between every
point. This does come with its pitfalls but it‚Äôs a very interesting
and cheap maneuver for manipulating points.</p>

<p>In BQN, generating the sequence of points is quite simple:</p>

<pre><code class="language-bqn">d‚Üê‚ü®0‚Äø1,1‚Äø1,0‚Äø0,1‚Äø0‚ü©
ZStep‚Üê{‚•äùï©+‚åúÀúd√ó‚äë1+¬Ø1‚äëùï©}
SZCurve‚Üê{ZStep‚çüùï©d}
</code></pre>

<p><code class="language-plaintext highlighter-rouge">d</code> is the sequence of points representing a single Z. If we arrange four
copies of the current iteration into a Z,
we get the next iteration. The size increases exponentially, so we have
to be wary on larger inputs. It makes for a easy to understand output,
however, good for plotting and understanding how the curve works:</p>

<pre><code class="language-bqn">‚Ä¢Plot¬¥&lt;Àò‚çâ&gt;SZCurve 2
</code></pre>

<svg viewBox="-10 -10 404 404">
  <g font-family="BQN,monospace" font-size="18px">
    <rect class="code" stroke-width="1" rx="5" x="-5" y="-5" width="394" height="394"></rect>
    <path class="Paren" stroke="currentColor" stroke-width="1" d="M0 0V384"></path>
    <path class="Paren" stroke="currentColor" stroke-width="1" d="M0 384H384"></path>
    <path class="red" style="fill:none" stroke-width="1" d="M0 0L54.857 0L0 54.857L54.857 54.857L109.714 0L164.571 0L109.714 54.857L164.571 54.857L0 109.714L54.857 109.714L0 164.571L54.857 164.571L109.714 109.714L164.571 109.714L109.714 164.571L164.571 164.571L219.429 0L274.286 0L219.429 54.857L274.286 54.857L329.143 0L384 0L329.143 54.857L384 54.857L219.429 109.714L274.286 109.714L219.429 164.571L274.286 164.571L329.143 109.714L384 109.714L329.143 164.571L384 164.571L0 219.429L54.857 219.429L0 274.286L54.857 274.286L109.714 219.429L164.571 219.429L109.714 274.286L164.571 274.286L0 329.143L54.857 329.143L0 384L54.857 384L109.714 329.143L164.571 329.143L109.714 384L164.571 384L219.429 219.429L274.286 219.429L219.429 274.286L274.286 274.286L329.143 219.429L384 219.429L329.143 274.286L384 274.286L219.429 329.143L274.286 329.143L219.429 384L274.286 384L329.143 329.143L384 329.143L329.143 384L384 384"></path>
  </g>
</svg>

<p>You can fiddle with the plot <a href="https://mlochbaum.github.io/BQN/try.html#code=ZOKGkOKfqDDigL8xLDHigL8xLDDigL8wLDHigL8w4p+pClpTdGVw4oaQe+KlivCdlakr4oycy5xkw5fiipExK8KvMeKKkfCdlal9ClNaQ3VydmXihpB7WlN0ZXDijZ/wnZWpZH0K4oCiUGxvdMK0PMuY4o2JPlNaQ3VydmUgMgo=">here</a>.</p>

<p>Z-order curves however may be required on much smaller areas which so not
fit exactly within the space of a square. Bit-weaving solves this problem
by letting us compute the z-ordering for a specific point, allowing us to
get an index without needing to generate a full grid.</p>

<p>For example, assuming that the maximum size of the grid is 7 (3 bits), we
can calculate the z-index of (1,2) like so:</p>

<ol>
  <li>Get the bits: <code class="language-plaintext highlighter-rouge">1 -&gt; 001</code>, <code class="language-plaintext highlighter-rouge">2 -&gt; 010</code></li>
  <li>Interleave the bits, last dimension going first:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 1 0
 0 0 1
------
001001
</code></pre></div>    </div>
  </li>
  <li>Convert that back to an integer: <code class="language-plaintext highlighter-rouge">9</code> is the z-index.</li>
</ol>

<p>A direct bit-based operation makes the usage of z-index very easy to order
points. These are called morton numbers, are they are also very useful for
simply getting unique hashes of points.</p>

<p>The easiest way to interleave bits given bit width is like so:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_iv1‚Üê{2|(‚åä√∑‚üú2)‚çü(‚åΩ‚Üïùïó)ùï©}
</code></pre></div></div>

<p>Bitwise tricks are much faster, however. I will be following
[Sean Anderson‚Äôs bit hacks]
(https://graphics.stanford.edu/~seander/bithacks.html#InterleaveTableObvious)
. He shows four different ways to do them, of which you can decide which
is most expressive for you.</p>

<p>First, let‚Äôs create a set of functions for us with the
required width. We require bitwise and, or, left shift and right shift.
Shifting operations are not provided by BQN, so we can multiply by two for a
left shift, and divide by two for a right shift.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ba‚ÄøBo‚Üê(&lt;8‚Äø8){ùï®ùïär:ùï® _r}¬®‚ü®‚Ä¢bit._and,‚Ä¢bit._or‚ü©
Bl‚Üê√ó‚üú(2‚ä∏‚ãÜ)                                                                      
Br‚Üê√∑‚üú(2‚ä∏‚ãÜ)                                                                      
</code></pre></div></div>

<p>Now, to interleave, we just go through the number bit by bit adding them to an
accumulator. The starting bit width is 3, and the ending width is 6, both fit
inside an 8-bit integer width.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_iv2‚Üê{x ùïó _ùï£ y:‚ü®0‚ü©{ùï© Bo((x Ba 1 Blùï®) Blùï®)Bo((y Ba 1 Blùï®)Blùï®+1)}¬¥‚Üïùïó}          
</code></pre></div></div>

<p>and voila! we have out first result:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   1 (3 _iv2)‚óã‚•ä 2
‚ü® 9 ‚ü©
</code></pre></div></div>

<p>The rest of the methods are lookup tables or use magic numbers, so I will skip
them for brevity‚Äôs sake.</p>

<p>Finally, we can do some computations with the transformed data. Since we know
that alterate bits contain alternate integers, we can add coordinates with the
following (for an 8-bit width):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x[i+j] = ((x[i] | 0b10101010) + x[j]) &amp; 0b01010101
x[i‚àíj] = ((x[i] &amp; 0b01010101) ‚àí x[j]) &amp; 0b01010101  if i ‚â• j
</code></pre></div></div>
<p>(Source: Wikipedia.)</p>

<p>Converting this to BQN is not very hard. <code class="language-plaintext highlighter-rouge">0b10101010</code> is 170 and <code class="language-plaintext highlighter-rouge">0b01010101</code>
is 85.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Zp‚Üê{85 Ba ùï©+ùï® Bo 170}
Zm‚Üê{170 Ba ùï©-Àúùï® Ba 85}
</code></pre></div></div>

<p>Using these we can now calculate points relative to a given point without
getting rid of its z-order data. This type of calculation is helpful in
constructing quadtrees, for example, since z-ordering properly segments the
points into four exact segments. A binary search tree is usually constructed
for this purpose, but we can simply use <code class="language-plaintext highlighter-rouge">‚çã</code> and <code class="language-plaintext highlighter-rouge">‚çí</code> to perform searches upon
a list of points, converting back and forth between z-order and cartesian
co-ordinates when necessary.</p>

<p>I never completely understood why BQN‚Äôs bitwise operations only worked on full
arrays until trying to write this. Even though the bit width is fixed, it helps
that the same conforming rules work correctly in bqn to make rank polymorphism
work.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[The code for this article can be found on Github.]]></summary></entry><entry><title type="html">Starting out in Fighting games</title><link href="https://razetime.github.io/blog/2023/08/12/beginner-fgs.html" rel="alternate" type="text/html" title="Starting out in Fighting games" /><published>2023-08-12T00:00:00+08:00</published><updated>2023-08-12T00:00:00+08:00</updated><id>https://razetime.github.io/blog/2023/08/12/beginner-fgs</id><content type="html" xml:base="https://razetime.github.io/blog/2023/08/12/beginner-fgs.html"><![CDATA[<p>I‚Äôve been ardently watching fighting games and smash for ages, and I decided one day in September 2022 to try out the genre. After a year of playing them on and off, I still find it hard to justify continuing to play them.</p>

<p>My first fighting game was third strike on fightcade. Later I tried Them‚Äôs Fighting Herds, Garou: Mark of the Wolves, Guilty Gear XX Accent Core +R, Undernight In-Birth cl-r, BlazBlue Centralfiction, and most recently, Skullgirls.
I‚Äôve spent the most time on Third Strike and +R, so that is mostly what my opinions of are based on.</p>

<p>Playing fighting games is like doing exercise without any of the physical benefits of exercise. Hell, you might even get some long lasting nerve problems and injuries if you don‚Äôt play them carefully.
The real time challenge of playing a fighting game will make you question your decision making, sanity, and your ability to use your controller of choice. Somehow, being a long time viewer didn‚Äôt help ease me much into this experience.
Knowing more things about the game doesn‚Äôt equate to being able to use that information. Being unable to use information is probably the worst, most helpless feeling that you can get in fighting games, and it turned up very early for me.
I would play several games versus a person, get tips I already knew about, and feel unable to execute much of it. It‚Äôs already far above what I can currently do, and after the genuinely crushing experience of losing 20 games,
I cannot help but long to kill myself. Which brings me to my first concern:</p>

<blockquote>
  <p>With fighting games, it‚Äôs like you have to basically take it on faith that there is an amazing game available to you after you spend years of your life training with the Shaolin monks.</p>
</blockquote>

<p>-pattheflip (Patrick Miller) in <em>From Masher to Master</em> (a really nice book for beginners)</p>

<p>Many fighting games often fall out of favour with newer players for good reason: they don‚Äôt do anything to ease that curve. You are confined to climbing a steep cliff face, and you have to hope that the next reward isn‚Äôt too far away.
CPUs encourage terrible habits and tutorials suffice to simply show the mechanics. The middle, aka gauging your skill, learning ‚Äúneutral game‚Äù, combos, pressure, learning motion inputs and executing them in different situations.
Fighting games in short rarely show you progress, especially if you play people better than you, which is what happens 99% of the time. You might work on an idea for a few days and have it simply shot down by a person that already
knows how to counter it. Or you simply don‚Äôt
get to play the game for 60 seconds and struggle to find a place where you get to do even the simplest improvement to your gameplan. In fighting games, being able to think calmly is hard. And most fighting games have a general design
that goes against this, having
moves that are generally infuriating to counter, and creative ways to disrespect the opponent. ‚ÄúIt makes me mad‚Äù and ‚ÄúIt makes me unable to think‚Äù are the hardest problems to work around in fighting games, and I don‚Äôt know how long that
takes to get over, if people can even manage such a thing.</p>

<p>Execution is one thing that people complain about in these games, and I think the basics of them are easy, and the motions are genuinely necessary. But it very quickly gets difficult and that is ok. I don‚Äôt like people that say that
execution simply comes over time, as if people cannot learn bad muscle memory and suffer for it later. People who have been playing the game for years often like to make short statements about how basic motion inputs are not hard,
or how playing neutral with limited execution practice is not hard, but that is simply not true. A single fireball in isolation is not a threatening motion, but how about when you want to backdash and fireball? you get a backwards DP
motion, which results in a slower special and probably will get you punished. How about out of a jump? after a jab? Each of these situtations can and will require a different adjustment and timing for the input. You have the general timings
memorized after years of practice, so please tell players that it is a hurdle that requires work to get consistent at. It‚Äôs possible to miss a diagonal in a fireball even after months of play, or even a short break.</p>

<p>Hell, learning a new character‚Äôs gameplan feels like learning a new game. It‚Äôs most amplified in faster games like guilty gear and blazblue but the shock of a new gameplan stays the same.
I played Bullet, my first grappler in Blazblue and I just
fundamentally can‚Äôt understand how to normally play the game with her. Coming from characters with ordinary movement it feels cool, and yet so overwhelming. You learn different kinds of patience and very different timings as a grappler.
People would say grapplers are easy and have simple gameplans, until they get zoned for 90 seconds and lose to hundreds of stray hits.</p>

<p>A good thing about fighting games is that choice of controller does not matter much, and usually you can play with a controller you already use, usually a keyboard. There are important differences, but every input method
has capability to be effective.
Blocking was easier when I started on keyboard, now I struggle to get down-back and other diagonal inputs on gamepad. Using gamepad is nice, but it feels like using a scalpel as compared to a knife, the keyboard. Which brings me to defense.
Defense is maybe the most non-obvious part of fighting games and ‚Äúwhen to press‚Äù changes based on player, and is rarely a universal truth. Defense is where you are forced to remember that you are facing a real person, and that you should
have been observing them.
It‚Äôs when you realize that there are meter and resources that make the opponent make different decisions, and affect your ability to defend. It‚Äôs nice to know how to defend, but most fighting games make sure that there is only
so much time you can defend for, either in the form of absurd options to open up opponents or just guard break limits that lead to devastating damage.</p>

<p>Fighting games feel like tons of homework, especially anime fighters, where you have to learn do certain things by default to avoid going insane. You can‚Äôt keep making conscious decisions every frame; you need to simplify your thought
process by knowing what you need for each character, and what you need for each game. The easiest way to do this, is a notebook. People say that you should be practicing for hours on
end, to grind your gears out until you become good with your favourite character, but it is easy to develop pain after just a single hour of playing a fighting game. The ideas of fighting game grind make no damn sense to me, even with
exercise, since it leads to aches for days. Spending more hours does not make the process feel any faster. Personally I feel that spamming moves with privileged characters is the most fun I ever get in these games, but I never feel entitled
to the small and big victories that doing such a thing gives, resulting in permanent negative feedback. It‚Äôs best to tell people that improving can be a chore, and that managing expectations while learning is much harder than they think.
Also, that finger and arm exercises are very important.</p>

<p>Overall I still do intend to play fighting games, recently Venom in +R, Bullet in BlazBlue, Gato and Marco in Garou Mark of The Wolves. People often talk about simply choosing the character you think is neat in these games, and
they often say that execution should never stop a person from playing the character. I feel it is complete nonsense that execution barrier doesn‚Äôt hinder one‚Äôs appreciation of a character, especially when certain motions are genuinely
disliked by a large number of people. Love for a character design can only carry you so far when the way said character plays just doesn‚Äôt work for you. I do want to stick with some cool characters, like ACPR venom, or bullet in BBCF,
but I‚Äôm not reluctant to
drop them if I can find a character that practically feels better to play. People learn at very different speeds, and it is entirely stupid to say that people overestimate the amount of time it takes to pick up a character. They know better
about themselves than you do. In +R and BBCF, the basics are so complicated that you first have to appreciate the game‚Äôs underlying systems before you can enjoy playing any of the characters in the first place.
Some of the facets of +R‚Äôs system are:</p>
<ul>
  <li>high reward for accurate aggression</li>
  <li>a slippery and fast physics system that lets you carry momentum from movement and specials</li>
  <li>moderately strong defensive options tied to meter</li>
  <li>complex universal air movement options</li>
  <li>flexible but restrictive ‚Äúgatling‚Äù combo system</li>
</ul>

<p>BBCF provides:</p>
<ul>
  <li>nearly endless offensive strings</li>
  <li>a complicated knockdown system</li>
  <li>a universal install super (overdrive) which also controls your burst resource</li>
  <li>and much more..</li>
</ul>

<p>These games don‚Äôt
do much to ease you into the characters, as much as they just show you the smallest glimpse of the ideas behind them, give you a pat on the back, and then leave. The rest you learn by getting smacked on the face by the few people
that continue to play the game in your region. And of course, online chatrooms and guidance pages.</p>

<p>Garou: Mark of the Wolves doesn‚Äôt do anything particularly different from the above two games, but somehow it manages to make the learning experience easier with its general design. Garou‚Äôs old input system is very lenient yet
responsive. Continuously playing the game will naturally give you an idea of how to defend. +R and BBCF reward you indirectly for instant block, providing you with frame advantage and meter gain, which are not as easy to capitalize on.
Garou on the other hand, is a low health, low timer game, and it simply goes all in.
If you just defend in Garou, you <em>get health back!</em> (among other things) And for when you get better, you can guard cancel to punish the opponent. What‚Äôs more, just defend has a clear
visual indicator and a text indicator even if you do it unintentionally, which automatically cements it in the player‚Äôs head as an important mechanic. Garou arguably is simpler in many ways, but I believe its systems come together in a
much nicer way. Garou‚Äôs movement and jump system is a little hard to use, but it is snappy. Even with its fair share of old game nonsense, namely the existence
of Grant and how the other top tiers are, it rarely feels overwhelmingly unfair. Garou is the one fighting game where after a month, I didn‚Äôt feel like I was hitting my head against a brick wall even against players close to my level.</p>

<p>If anything keeps me motivated it‚Äôs that there‚Äôs always good people to talk to and usually good people to play with. Finding a real life community for the games I like may make this learning process much nicer, but alas, I‚Äôm very much
out of luck. Sticking with a game is the best I can do, and I‚Äôll try my best as long as I have the energy to keep on rockin‚Äô.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[I‚Äôve been ardently watching fighting games and smash for ages, and I decided one day in September 2022 to try out the genre. After a year of playing them on and off, I still find it hard to justify continuing to play them.]]></summary></entry><entry><title type="html">Dice Games</title><link href="https://razetime.github.io/blog/2023/05/10/dice-games.html" rel="alternate" type="text/html" title="Dice Games" /><published>2023-05-10T00:00:00+08:00</published><updated>2023-05-10T00:00:00+08:00</updated><id>https://razetime.github.io/blog/2023/05/10/dice-games</id><content type="html" xml:base="https://razetime.github.io/blog/2023/05/10/dice-games.html"><![CDATA[<p>A certain video game has gotten me into dice-based board games again, and I came to wonder why I stopped playing them as much.</p>

<p>I play chess and go semi-regularly, but those games have determined, well-defined strategies to win. To some degree they are fair,
and they provide many ways for any player to equalize. Chess and Go are very painful to lose at, in a sense that any of the many
mistakes you can make are entirely your fault, and that hurts a lot more than other games, and it makes the game feel a lot less
casual. So, it‚Äôs no surprise that I‚Äôve been playing games with a ton of RNG recently. Spelunky 2 is almost equally as
demoralizing as chess, somehow both of these games keep finding brand new ways to kill you. I‚Äôve reached Tiamat several times
and failed, and sometimes it feels like finding a way to win may be neverending.</p>

<p>Which brings us to dice games. I‚Äôd never been a huge fan of RNG in the past, and so do many impressionable children when they
play Snakes and Ladders as their first dice game. It has little sugarcoating above plain old dice rolls, and it is moderately
funny to see people in the lead get wrecked by a long snake. Snakes and Ladders makes every loss feel undeserved, and every win
feels undeserved. The only gratification we get is laughing at other people‚Äôs despair as they descend downwards. Other well-known
dice games like Ludo add <em>some</em> strategy to the mix, letting the player choose a unit to move, and choose whether they want to
introduce units into the game. But, that is the most control you get over the game. It feels unsatisfying to play these games
because they don‚Äôt require you to think much. It‚Äôs much better as a reason to sit around a table and talk to people.</p>

<p>So then we come to <em>Business</em>. Which, outside India, is called Monopoly. Business has a lot more interesting ideas and systems
in place, particularly a resource (money) that can be used, gained and stolen. Business is a high-setup, high-skill game, but it
gives all players random chances to lose as much as they can win. The complication of Business, together with calculation or
reckless risk-taking feels incredible to play when you do get rewarded, almost unlike any other board game. the problem with
Business is that tracking player properties and planning strategy is overwhelming, and it has to be done for a high number of
rounds. I have never seen a Business game of more than four players complete in my life. It seems that much better longtime
players can manage it though, and it comes around to 45 minutes a session, shorter if the players are good. A serious problem
with Monopoly though, is that it doesn‚Äôt keep players on the board. Once you are bankrupt, you are dead. As turns go on, moving
a lot becomes vastly worse. It doesn‚Äôt allow comebacks and it rewards very miserly, slow play once the initial rounds are over.
Even though not a hallmark of design, it does provide a lot of useful ideas.</p>

<p>A non-RNG game that uses players themselves as RNG is Scotland Yard, a game that uses cards to build much better
confusion. Few things compare to playing Mr. X in Scotland Yard, and the game lasts just long enough to avoid
being a chore. The twisty and well-placed routes of Scotland Yard make the cat-and-mouse chase of it all a lot more gratifying,
as it integrates detective work into a much better, layered movement system that rewards a correct prediction with a nicer
chance at getting the catch. There is a dice game version but it id of doubt that it preserves the speed of this game.</p>

<p>So, after going through several fighting game crises, I found that I still had an old copy of 100% Orange Juice (OJ) lying in my
Steam library, from the time it was released for free. It has clear Mario Party Influences, revolving around gaining and losing
stars, but it also combines ideas from several of the aforementioned games, including ability cards, stats, a simple battling
system, default enemies, bosses, and characters with varying stats. OJ does things with a board game that only a computer could, because even though playing the game in real life is humanly somewhat feasible, it is much nicer to have the computer
fairly and correctly organize your resources in a second, as opposed to taking a few minutes. This complexity never gets in the
way of OJ‚Äôs success, as it clearly delineates beginner characters and comes with simple story-oriented games for learning its
basics.</p>

<p>But really why OJ is so addicting is that somehow it manages to keep the chaos unfair for everyone. Every character‚Äôs design
feels so purposeful as you play more games with them, and it genuinely feels rewarding to pull off risky business, or just use a
character‚Äôs base mechanic. Lone Rider is a famous example of this, who has a hyper card that gives him the ability to zoom
across the board. He has to lose his speed in order to level up, making him a strong opportunist that has to pick his speed-up
times very wisely. OJ takes a lot of liberties being a computer game, adding in visual and animated flourishes that keep
everything so fresh even when there is little happening on the board. And if the past two weeks have been indicative of anything,
I definitely will be playing it for a long time.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[A certain video game has gotten me into dice-based board games again, and I came to wonder why I stopped playing them as much.]]></summary></entry><entry><title type="html">Keyboard Controls</title><link href="https://razetime.github.io/blog/2023/05/01/keyboard-controls.html" rel="alternate" type="text/html" title="Keyboard Controls" /><published>2023-05-01T00:00:00+08:00</published><updated>2023-05-01T00:00:00+08:00</updated><id>https://razetime.github.io/blog/2023/05/01/keyboard-controls</id><content type="html" xml:base="https://razetime.github.io/blog/2023/05/01/keyboard-controls.html"><![CDATA[<p>Keyboard controls vastly vary with every video game, but they often have the same homogeneous interfaces that let the user customize
them.</p>

<p>I find it to be a pain that games from 2000 and 2023 both sport basically the same design for these interfaces as well.</p>

<p><img src="../../../../img/deusexkeys.png" alt="Deus Ex keyboard controls" /></p>

<p><img src="../../../../img/spelunkykeys.png" alt="Spelunky 2 keyboard controls" /></p>

<p>One difference is that Deus Ex lets you set more than one key/mouse button to a control, which is pretty useful in a first
person game. The problem then, is that it‚Äôs very hard to find out what a button actually does in the game. A search
tool is a simple idea that makes this much easier. Just press a button and the game will locate the action it does for you.</p>

<p>Another problem I encountered was when I accidentally bound left click to the wrong action, resulting in an
hour of pain trying to figure out what the hell went wrong. There was no useful way to find out what it was originally bound to
other than a reset, but I had already customized it to a point where a reset would mean even more work. That brings me to my
next gripe. When a keyboard control is changed, you should show what it was previously bound to.</p>

<p>What can make the experience even worse is if the menu for setting controls <em>uses</em> the controls that you are setting. This is
notable in Guilty Gear Accent Core +R (Steam version), where changing ‚Äòup‚Äô to a different key means you have to awkwardly use the
menu with the new control. Them‚Äôs Fighting Herds, a newer fighting game also forgets about this. When the user is setting new
controls, the controls for the menu should not change. Guilty Gear Strive only half fixes this by having another menu for setting
the controls for using menus in the game. One way i can think of, is that once new controls are set, it updates all at once when
you exit the menu.</p>

<p>Finally, when I do set controls I want to try them out. Give me a chance to check my buttons immediately. Accent Core +R luckily
does solve this somewhat by letting players change controls in practice mode, but it‚Äôs still a hidden quality of life feature.
Please make it obvious.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[Keyboard controls vastly vary with every video game, but they often have the same homogeneous interfaces that let the user customize them.]]></summary></entry><entry><title type="html">Transistor, an RPG by Supergiant games</title><link href="https://razetime.github.io/blog/2023/03/12/transistor.html" rel="alternate" type="text/html" title="Transistor, an RPG by Supergiant games" /><published>2023-03-12T00:00:00+08:00</published><updated>2023-03-12T00:00:00+08:00</updated><id>https://razetime.github.io/blog/2023/03/12/transistor</id><content type="html" xml:base="https://razetime.github.io/blog/2023/03/12/transistor.html"><![CDATA[<p>Spoilers for the entire game. be warned.</p>

<p>Transistor is set in this sort of hyperfuturistic tech utopia, where realistic imbalance and the base humanity of people seems
to be intact. The most notable thing you can see immediately is that you can harvest abilities from people and use them as your
own. I initially thought of this power as a device to raise moral questions about how work is treated in current capitalist
societies, and how this weapon could function as a brutal metaphor for it. The use of this weapon however, is simple: throughout
the story it is heralded as an inimitable, all-powerful weapon that is an excuse for our singer protagonist to endure an
onslaught of robots. It is a special superuser key, a be-all-end-all object that somehow with its existence makes the story
boring.</p>

<p>Supergiant never goes far with the ideas that the transistor very directly provides with its design, instead going for a
different approach. There are a few reactionary thinkers 
(probably named after the <a href="https://en.wikipedia.org/wiki/Florentine_Camerata">Florentine Camerata</a>)
who instead of attempting to draw an audience to their ideas take
anti-social shortcuts. In the process they find the transistor, which lets them steal the abilities of several gifted people in
order to impose their will on the city. The idea is to completely reset the city, which I am guessing is Los Angeles But What If
It Was Good. The go on a killing spree with the transistor, and naturall mess up their plans when they get to Red, who is saved
by her unnamed lover. This messes with the algorithm and effectively makes the ‚Äúprocess‚Äù, the Camerata‚Äôs cultural reset tool go
berserk and start outright destroying stuff. In some ways the powers that celebrities have in the Transistor ingame universe
are supernatural. Red‚Äôs singing for example, caused nondescript amounts of insanity in her crowds, the implication being that
killing her with the transistor would provide crowd control abilities, allowing them to effectively convince the people of
Cloudbank that this was a good idea. This didn‚Äôt happen, and the gameplay starts at that point of the story.</p>

<p>Now, alongside this story is a romance narrative that is very unconvincing, but even outside of that, all the piles of lore that
this game accumulates ends up being largely unconvincing, as it rarely ever uses these lore bits for any commentary. Red never
undergoes much development and she‚Äôs never made to question what she does. The transistor is meant to be the main speaking
protagonist and he is nothing but annoying after the tutorial sections. Even though the transistor contains her fiancee now,
I see no connection, no charm, no love in their relationship. The artistic choices here baffle me, cause they do expect you to
buy the connection between red and her lover, who is now a USB greatsword. The ending has some logic to it, in that the
transistor needed to be given to the process. But, in some ways it also makes sense that adding Red to the transistor would
immediately halt the process as that was the reason it malfunctioned in the first place. The ending here is also baffling in that respect, since she cared enough to preserve herself in the ‚Äúreal‚Äù world, fighting stuff she had no experience with, and still ended up killing
herself to have a chance at seeing a neutered virtual version of her lover. Basically everything about the story ends up being a
massive disappointment, even though it is an interesting experiment.</p>

<p>The gameplay is a combination of hack-and-slash, puzzle mechanics, and turn based games. The enemies, however, are pretty
ordinary, and they don‚Äôt always counter the player‚Äôs improvement so much as they outright attempt to nullify whatever useful
abilities you have. This means they have perfect aim, perfect tracking, healing stations, quick recovery. And later in the game
they get to obscure your vision, they get stealth, nuke shells, and they are even more slippery. The player character does not
have enough health to survive that stuff, and this is where we get to Turn():  the time stop mechanic. What this effectively
lets you do outside of real time attack (and defense, which is simply running behind walls and/or dashing) is plan attacks to
obliterate many robots in one fell swoop. Even though the abilities have been seen in many RPGs, the intentionality of every
aspect of their design shows up here. You‚Äôll have to predict timing for each attack, see things the predictive system of turn
doesn‚Äôt see, and combine effects from multiple abilities with your positioning to make things work correctly. Robots respawn
at <em>full health</em> if you don‚Äôt collect their fallen parts (called ‚Äòcells‚Äô), so you have to plan getting those along with
attacking.</p>

<p>Transistor avoids satisfying offense in order to emphasize the turn mechanic. In the process it makes ordinary offense painful
and rarely ever worth it outside of the time stop. Assuming perfect play, it would be adequate to simply spam turn and hide.
However, the usual problem after smacking a robot with Turn() is that you have to run for a few seconds as overpowered robots
with twice your walk speed run you over. The dash attack is useful sometimes but even with its combinations it is woefully
inadequate. You still rarely ever have to reconsider your strategy for most waves, as you have four lives to deal with the
robots in every single save. There is a catch though. Supergiant games for some reason decided to neuter your game by <em>removing</em>
a single ability every single time you die, making the game more unbearable to play with every life. They could just kill me and
ask me to change my strategy instead, cause not everything needs to be unique.</p>

<p>The place where I think transistor succeds best is in its practice rooms and challenges (backdoor). The curated, well documented areas of
the game are much better suited to the game‚Äôs mechanics, and they teach you an understanding of the game much better than any of
the areas in the main storyline. It‚Äôs a shame that these are only sparsely accessible and unlock based on level, because they
are simply marvelous to finish (and exist as some of the only truly difficult areas in the game). These parts are so well
designed because they teach you how the puzzle pieces lock together, how your build can do crazy damage by limitng your options
and number of turns. Maybe in a future title, these ideas will have a better home, anda better story to go with them. The
beautiful isometric vistas could use some life to them. Drawing and experimentation alone did not end up at good art, but it
might help them create something truly impressive in the future.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[Spoilers for the entire game. be warned.]]></summary></entry><entry><title type="html">Common misconceptions about APL</title><link href="https://razetime.github.io/blog/2023/03/02/apl-assumptions.html" rel="alternate" type="text/html" title="Common misconceptions about APL" /><published>2023-03-02T00:00:00+08:00</published><updated>2023-03-02T00:00:00+08:00</updated><id>https://razetime.github.io/blog/2023/03/02/apl-assumptions</id><content type="html" xml:base="https://razetime.github.io/blog/2023/03/02/apl-assumptions.html"><![CDATA[<p>This page will be updated later, and without notice.</p>

<p>APL and other array languages are often unfairly judged by developers on the internet for the qualities that make them differ
from what most programmers daily use. This attempts to counter some common misconceptions and predisposed ideas about APL
people like to repeat on any APL related media.</p>

<h6 id="apl-is-so-unreadable">APL is so unreadable!</h6>
<p>This often comes from people who have not learned APL, and there is usually a response asking them to read the fucking manual.
The real problem is that programmers expect every language to be same-ish. Expecting to understand a language without
learning it is entitled nonsense. Most languages use familiar keywords and operators, and they contain long words everywhere.
This is the worst lens to view APL from, as it was made by a mathematician. APL in some sense acts like a linguistic language,
and it contains its own identity. If you learn the identity, you can then do informed criticism, which is much more productive.
You can even look at genuine criticism of Array languages from informed people
(like Daniel Sockwell does <a href="https://raku-advent.blog/2020/12/01/day-1-why-raku-is-ideal-for-advent-of-code/">here</a> and <a href="https://www.arraycast.com/episode-4-daniels-email">here</a>)
to gauge if you want to learn it. Even that is better than simply dismissing it altogether.</p>

<h6 id="apl-is-similar-to-regex-apl-is-an-esolang-et-al">APL is similar to Regex, APL is an esolang, et al.</h6>
<p>APL is not designed to experiment with language development ideas, to be hard to program in, or as a joke. It was carefully designed by Ken
Iverson to be usable as a programming language, and it has gone many evolutions to come to its current matured state.
Many people like to say that APL is ideal for golf and horrible for production. This has been proven wrong in practice time and
again by the many companies productively using APL and its successors commercially. Any language can be successfully used in
code golf. APL‚Äôs conciseness helps with low byte count, but understanding well-written ungolfed APL is understandably much easier,
<em>just like any other language</em>. Many programmers cite the conciseness of APL as a prime reason for why they love programming
in it‚Äîthe obvious idea is that it takes less time to write, but understanding how purposeful this conciseness is makes reading
APL easier. Going a step beyond, there are programmers like Elias Martenson who like to write verbose APL with copious amounts
of whitespace. If that doesn‚Äôt fit your programming philosophy, please just state that instead of making unfounded claims about APL.</p>

<hr />
<p>The most important thing I want to say is: learn to hate on APL. Correctly.</p>

<p>This doesn‚Äôt require learning APL thoroughly as much as understanding how other languages have limitations that APL covers, and how
APL has limitations that most of the languages you use cover.</p>

<p>There‚Äôs problems with APL, both in and outside of its design, some of them being the fact that most production ready array
languages are proprietary, and the various problems with several legacy features that cannot be removed. There are people 
seeking to elminate these problems, however. There‚Äôs many advancements and important discussions
happening around APL, and useful criticism from people outside of the APL spectrum is very much needed. I hope that this
article was of some help in addressing the biases that prevent people from contributing to a language I love.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[This page will be updated later, and without notice.]]></summary></entry><entry><title type="html">Mob Psycho 100</title><link href="https://razetime.github.io/blog/2023/03/02/mob-psycho.html" rel="alternate" type="text/html" title="Mob Psycho 100" /><published>2023-03-02T00:00:00+08:00</published><updated>2023-03-02T00:00:00+08:00</updated><id>https://razetime.github.io/blog/2023/03/02/mob-psycho</id><content type="html" xml:base="https://razetime.github.io/blog/2023/03/02/mob-psycho.html"><![CDATA[<p>Beware of spoilers.</p>

<p>Mob Psycho is a chronicle of adolescence from ONE that brings his style of supernatural fiction into a middle schooler‚Äôs social
life. Mob, a tiny teenager with a terrible haircut is the guy we‚Äôre looking at, and the very first scene we see is of him
being exploited by a fake psychic. One of Mob‚Äôs greatest weaknesses, just like any teenager is his lack of experience with
people. In a different story Mob might have developed a sad, cynical view of the world, but like in most of ONE‚Äôs work, the
people Mob encounters in his daily life tend not to be explicitly antagonistic in nature.</p>

<p>Mob is a stoic, stubborn kind of fool in that he refuses to be practical even when the situation demands it. He always
stubornly follows his own logic int he face of reality, and luckily his powers are enough to pull him through most situations.
Yet here we get to see something very important in Mob: he is very afraid of himself. Even though Mob can beat every
natural and supernatural enemy he faces, Mob hesitates to use his powers in any regard. Reigen, his mentor does well in
empathizing with Mob‚Äôs tendencies and powers, but he still doesn‚Äôt know exactly what it feels like. This is the crux of Mob‚Äôs
behavious throughout the series, and this facet of Mob‚Äôs character even though moderately explores doesn‚Äôt seem to get enough
time.</p>

<p>What makes Mob‚Äôs story so interesting is the number of things in adolescence it is explicitly not about. ONE manages to
reuse many of his tropes without making them feel stale. Mob Psycho never attempts to tackle bodily change, or romance, or
the various failures of modern schooling. It‚Äôs a very Spider-man like narrative, generally staying within the bounds of Mob‚Äôs
city. That makes it feel a lot more personal, revolving around a limited neighbourhood of people and places.</p>

<p>The most important message that comes from every episode is that kids rock. It doesn‚Äôt avoid writing children like children, and
yet it capture how spart and perceptive they can be. When you look at a conversation between kids or adult, you can see a 
distinction in the narrowness of their thinking. Children are reflective of what their circumstances have given them, and a lot
more so than adults. And even better is how ONE represents growing up in the show, as some of the espers in Mob Psycho haven‚Äôt
been given chances to live happily, grow up or be happy with themselves.</p>

<p>By avoiding some harsh realities, but not all of them, moddle school becomes a vital microcosm of the wider world that Mob
Psycho represents. Exploring the identities of ghosts in the real world and the spirit world, it draws clear yet complex 
analogies between the two. Near the heart of Mob‚Äôs moral compass in all these weird happenings are Reigen and Dimple, who act
as his parents in supernatural situations. Even despite their shortcomings and individual interests in Mob‚Äôs abilities, they
still care for him as well as a parent can. It‚Äôs not more obvious than it is in modern times that simply having two parents is
not enough, and that kids have to be given the agency to learn from any of the adults they trust. Mob is definitely lucky here,
but most people tend to be walled away from the people they can discuss their most private problems with. Adding this to the
general stigma that dismissed teenagers are dumb and impulsive, it‚Äôs no surprise that many of then come out with several mental
issues.</p>

<p>While Dimple has probably the greatest episode in the series, Reigen is there in every great moment of the series. The initial
distaste for the fraud disappears quickly as you realize that Mob‚Äôs respect for him, fraud or not, is completely genuine.
Reigen is still very possessive of Mob‚Äôs attention and after-school time, and this does come to bite him later. But even when
you come to think that Reigen‚Äôs incredible luck could have made him relatable to Mob, it becomes more apparent that he is
nothing short of the most brilliant, practical and resourceful characters in the series. Everything he does with Mob essentially
puts his life at stake against entities he has no clue how to fight. Keeping par with Mob‚Äôs unrealistic standards, and maybe
pushing those ideas too far, Reigen manages to be, in the end, a good person whose role cannot be replaced or imitated.</p>

<p>Studio Bones uses a snappy, hyper elastic animation style to translate ONE‚Äôs manga, as many of the faces and character designs
are pretty ordinary or unappealing. To some degree, this mimics reality. Obsessed with the gestures of the body, and to a more
specific extent, the various shapes that hands can take in comedy and in every twist and turn of the story, the movement is what
is important. Sometimes I still find myself losing track of what‚Äôs going on in screen. Reigen‚Äôs hands are a character of their own,
so much so that a change in his body language can indicate a change in heart, or a loss of agency. That vigour which is put into
the images of hands in the physical and psychic world is very pertinent.</p>

<p>Naturally, ending this show was not easy. The final episodes are probably the worst episodes of the show, as they just can‚Äôt
follow a simple
chronological and thematic sequence. The insistence on ending the show with Mob‚Äôs crush feels weaker as the show goes on, but
ONE‚Äôs visuals in this matter do their best to make it fit in. Seeing Teru and others get demolished just did not feel like it
was right for an ending of the show. But, hey, at least the final few moments make sense, with Reigen showing his true self, and
Mob not afraid to be his true self. Reigen again has to confront his mortality, maybe not for the last time, but just for one
important moment. In the end, the true ending was after all, the friends we made along the way, and those friends are more than
enough. Even in the most desperate, sad, tortured souls like Mogami Gensai, there was still a small glimmer of hope. And that
hope was enough.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[Beware of spoilers.]]></summary></entry><entry><title type="html">Fangames and Chungo‚Äôs Gauntlet</title><link href="https://razetime.github.io/blog/2023/02/16/fangame-chungo.html" rel="alternate" type="text/html" title="Fangames and Chungo‚Äôs Gauntlet" /><published>2023-02-16T00:00:00+08:00</published><updated>2023-02-16T00:00:00+08:00</updated><id>https://razetime.github.io/blog/2023/02/16/fangame-chungo</id><content type="html" xml:base="https://razetime.github.io/blog/2023/02/16/fangame-chungo.html"><![CDATA[<p>Despite my liking for watching fangames, I had always been afraid of playing them.</p>

<p>I used to have a save somewhere in the middle of <a href="https://kayin.itch.io/iwbtg">I Wanna Be The Guy</a> (IWBTG) many years ago, and I never considered 
touching a fangame ever since.
I Wanna Be The Guy used to be one of the few games that used to run on my old XP machine without any complaints. Alongside Osu,
Super Hexagon, and several flash games on Kongregate, that used to be one of the few games I tried to complete. Needless to say,
I failed at that.</p>

<p>IWBTG doesn‚Äôt hold your hand, it is troll-heavy, and it is very, very difficult. Many other games have been made
in its style now, plainly called ‚Äúfangames‚Äù, some of which have gained popularity in streaming: <a href="https://www.delicious-fruit.com/ratings/game_details.php?id=11890">I Wanna Be the Boshy</a> is one that
brought me into looking at fangame speedruns (largely from witwix and BBF), and one day I happened upon I wanna Kill the Kamilia 2 (K2) on BBF‚Äôs
stream. Kamilia 2 is a game most people shouldn‚Äôt end up playing in their lives (and so is Boshy to some extent), but it is
much more effective in showcasing the sheer range of fangames available. K2 is a ‚Äúmedley‚Äù fangame, which strings together content from hundreds
of fangames into one single behemoth of shifting difficulties and genres. I am not kidding when I say that K2 has a
<em>minesweeper</em> level hidden in it. From watching any popular fangames most would conclude that they are too difficult to even
start with. Even Kamilia tends to point toward the more difficult ones among the bunch.</p>

<p>Fast forward to 2023, I came upon a realization in another BBF stream that there may be nicer introductions to the genre. There
were some kind souls who pointed at <a href="https://cwpat.me/beginner-fangames/">cwpat‚Äôs beginner fangames list</a>, and I instantly knew
I was going to play chungo‚Äôs gauntlet.</p>

<p>Many fangames mimic the style of the classic IWBTG:</p>
<ul>
  <li>Using the original kid, his shooting and double jump physics</li>
  <li>Borrowing assets and sounds from several video games and using them for theming</li>
  <li>Troll platforms and unexpected deaths</li>
</ul>

<p>In general it seems like IWBTG was a space for a younger Kayin to create a fun, twisted game  while paying homage to his own
inspirations. He even shows a great understanding of why intellectual property is nonsense, and the technicalities of how his
game borrows from other franchises and I think that has carried his ideas a long way. There are now thousands of fangames
available, and an excellent level creator in <a href="https://www.iwannamakergame.com/">I Wanna Maker</a>, making it very easy to
start creating platformers and see people play them. Chungo‚Äôs gauntlet however isn‚Äôt exactly in the same vein.</p>

<p>Even though it is well known as a fangame, Jane_Chef‚Äôs game Chungo‚Äôs Gauntlet is still very much it‚Äôs own thing. The physics, main character and
the platforming style is a big departure from the other games on cwpat‚Äôs list, and it even has the pluck to add natural difficulty
progrssion into the platforming. You only get a double jump around 3/4ths (?) in to the game, and most of the time you don‚Äôt
require the gun. Chungo‚Äôs Gauntlet despite being a massive meme, is also an excellent place to see how Jane has improved her 
game making skill from her previous games (see: <a href="https://jane-chef.itch.io/chungo-kong-2">Chungo Kong 2</a>). It completely manages
 to shrug off the feeling that the game is made from scraps of
other games, seamlessly blending its own artwork into the fabric of the games it‚Äôs inspired from. Even the troll sections
become increasingly more readable, it‚Äôs just so smart to make even that masterable in some sense. The player is trained to read
background sprites and guess the effect of a troll before they land on it. Maybe the only genuinely unfair part of this game is
the bullet hell bosses, which do occasionally come up with impossible patterns.</p>

<p>My favourite parts of this game among the many beautiful stages was the LISA the painful stage (hehe Lois I‚Äôm a JOY MUTANT),
the one where you play Simon Says with the rock, and the ticking time bomb. Even in the sheer variety of platforming challenges
available, it doesn‚Äôt compromise on creativity or its sense of balance. Even among the other games I‚Äôve been playing lately, it
felt incredibly fulfilling.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[Despite my liking for watching fangames, I had always been afraid of playing them.]]></summary></entry><entry><title type="html">Lil and Advent of Code</title><link href="https://razetime.github.io/blog/2022/12/31/lil-aoc.html" rel="alternate" type="text/html" title="Lil and Advent of Code" /><published>2022-12-31T00:00:00+08:00</published><updated>2022-12-31T00:00:00+08:00</updated><id>https://razetime.github.io/blog/2022/12/31/lil-aoc</id><content type="html" xml:base="https://razetime.github.io/blog/2022/12/31/lil-aoc.html"><![CDATA[<p>This year‚Äôs Advent of code language was Lil. I skipped day 16, 19, 22 part 2, 24 and 25.</p>

<p>This year I figured I shouldn‚Äôt put too much pressure on myself, so I didn‚Äôt solve anything that took more than 3 hours. I was 
solving the problems in Lil, using the <strong>CLil</strong> implementation. I usually post my solutions on reddit, so if you‚Äôve seen me on
the threads, hi!</p>

<h6 id="lil-vs-other-array-languages-in-aoc">Lil vs other Array languages in AOC</h6>

<p>The APL crowd on reddit every year usually consists of /u/jayfoad, /u/voidhawk, and a few newcomers (/u/jaybosamiya has been there
since last year). Advent of Code usually isn‚Äôt amazing for array languages, so it‚Äôs a good place to check how well you can make
things work, gauge how well array languages fit with your methods of thinking.</p>

<p>An honorable mention to /u/TeddyDD93, who was also solving in Lil till Day 6.</p>

<p>This year has copious amount of simulation and pathfinding, both of which need some level of involvement to express well in array
languages. <a href="https://futhark-lang.org/blog/2022-12-25-reflections-on-advent-of-code.html">Troels Henriksen</a> has stated that this
year‚Äôs problems allowed for meaningful parallel computation, and I hope I managed to do some justice to that.</p>

<p>The most common problems in AOC arise from having to do one thing at a time: imperative algorithms, lots of mutation, or something
along those lines. Lil merges the ideas of Lua with K, ending up with a frankenstein that is really fun to use. Lil mainly
differs in the lua aspect, having explicit loops with good syntax:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>each x in arr/dict/table
end
while x
end
</code></pre></div></div>
<p>The parts where Lil is like an ordinary scripting language are painstakingly integrated into the array language hidden inside it:
all tables, dicts, lists are treated equally in loops and vectorized operations. Lil is also juggling these ideas along with the
ideas present in Decker, its parent environment.</p>

<p>Lil sounds great for advent of code so far, having dictionaries and lists, almost pythonic in nature, but Lil is also made to have
as few errors as possible. It is of note that I only ever had two types of errors turn up during December:</p>
<ul>
  <li>Syntax errors (more often than not, from multiple <code class="language-plaintext highlighter-rouge">end</code>s)</li>
  <li>Segmentation faults (implementation issues, or me fumbling with array interfaces)</li>
</ul>

<p>This is because <em>basically</em> everything else that doesn‚Äôt make sense to Lil always returns a 0. Sometimes <code class="language-plaintext highlighter-rouge">""</code>. Regardless, this
causes a lot of confusion in code cause you have no idea where you created a zero. One zero in a weird place creates newer, funnier
zeroes everywhere. Print debugging with <code class="language-plaintext highlighter-rouge">show[]</code> is useful, just like in every array language.</p>

<p>Lil is only mildly frustrating due to the above problem, my main pet peeve was that it was so long to write and rewrite array 
oriented things in it. Something like <code class="language-plaintext highlighter-rouge">&amp;'</code> in K becomes</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>each x in lst
  extract index where value from x
end
</code></pre></div></div>
<p>Conciseness is a boon, and it became much more obvious when I rewrote the solutions in BQN. Lil also doesn‚Äôt contain many K
primitives due to arbitrary design constraints, but K‚Äôs features are very much present just in more verbose ways. Factoring out
these primitives into functions is useful, but it results in the Q problem: you have so. many. square brackets.</p>

<p>Speaking of arbitrary design constraints, <code class="language-plaintext highlighter-rouge">else if</code> is not present in lil, which led me to a lot of cases where
<code class="language-plaintext highlighter-rouge">end end end end end</code> became a common occurrence. If it weren‚Äôt so funny, I probably would have quit using lil for Advent of
Code.</p>

<h5 id="the-lil-experience">The Lil Experience</h5>
<p>Lil overall is a very competent scripting language. You can load your own library functions from different files with</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>libname:eval[read["lib.lil"]].vars
</code></pre></div></div>

<p>lilt‚Äôs <code class="language-plaintext highlighter-rouge">eval[]</code> is a bit weird, however, and doesn‚Äôt have native functions available. Always 
make sure to return a string for formatting helpers, so you can print it in your actual program.</p>

<p><code class="language-plaintext highlighter-rouge">parse</code> is really versatile, and it works extremely well on a variety of problems. <code class="language-plaintext highlighter-rouge">split</code> and <code class="language-plaintext highlighter-rouge">parse</code> together were easy pickings
for input parsing <em>and</em> validation for most of the days. I wish I could specify repeating patterns, but that is obviously too
much to be asking from lil. <code class="language-plaintext highlighter-rouge">glguy</code> from the <code class="language-plaintext highlighter-rouge">#adventofcode</code> IRC on libera.chat had an interesting library that did so.</p>

<p>Dictionaries are terrible for performance. They are <em>ordered</em> sequences of pairings between keys and values, so lookup is painfully long. They
are still worth using, just in limited amounts. I should have made my own hashmap implementation or a tree based implementation,
but I realized that I needed faster ones too late.</p>

<p><code class="language-plaintext highlighter-rouge">each</code> loops are also slow in the long term. I recommend <code class="language-plaintext highlighter-rouge">each</code> only if you plan on using every intermediate result. <code class="language-plaintext highlighter-rouge">while</code> loops
with counters are the way to go for most things, especially useful in the simulation tasks where you‚Äôre doing thousands of 
iterations.</p>

<p><code class="language-plaintext highlighter-rouge">in</code> is a vectorizing binary operator, so you cannot check if a list is present in a list of lists. You‚Äôll need a combination of
<code class="language-plaintext highlighter-rouge">each</code>, <code class="language-plaintext highlighter-rouge">~</code> and <code class="language-plaintext highlighter-rouge">max</code> to get the same result.</p>

<p>Lil overall is pretty slow, and it has a lot of leeway for optimization. Using it for Advent of Code in itself is a challenge,
because it is made to be small and cozy, mainly to fit well with Decker. I did intend on making a visualization for one of the 
days, but it got too time consuming to solve the problems themselves. Some days took <em>very</em> long to run, and it was obvious that it was not smart to wait more than
an hour to wait for day 16 to execute and potentially provide a wrong result. It was still quite fun, and I might actually do it again,
if I feel like testing my patience.</p>

<p>A big thanks to all the people this year who made Advent of Code a little less lonely and a little easier to understand and solve.
Kacarott, chunes, gifti from Factor, hyperneutrino, Unrelated String, emanresu, Aiden Chow from Stack Exchange, Lyricly and 
umnikos from Esolangs. Most importantly, thanks to John Earnest for making such a cool environment, and providing helpful support
for it throughout November and December. I hope all of you had a great December, and I wish that you have a great year ahead in 2023.</p>

<p><strong>Advent of Code Links</strong></p>
<ul>
  <li><a href="https://github.com/razetime/aoc">My Solutions</a></li>
  <li><a href="https://mlochbaum.github.io/BQN/community/aoc.html">BQN solvers</a></li>
  <li><a href="https://k.miraheze.org/wiki/Advent_of_Code">K solvers</a></li>
  <li><a href="https://apl.wiki/Advent_of_Code#Individuals%27_solutions">APL solvers</a></li>
</ul>

<p><strong>Decker links</strong></p>
<ul>
  <li><a href="https://beyondloom.com/decker">Decker</a></li>
  <li><a href="https://beyondloom.com/decker/lil.html">Lil documentation</a>, effectively my bible for this month</li>
  <li><a href="https://itch.io/jam/decktember/entries">Decktember submissions</a></li>
  <li><a href="https://github.com/1jss/awesome-decker/issues">Awesome Decker</a></li>
  <li><a href="https://www.arraycast.com/episodes/episode43-john-earnest-decker">John Earnest on the Array Cast, Dec 23</a></li>
</ul>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[This year‚Äôs Advent of code language was Lil. I skipped day 16, 19, 22 part 2, 24 and 25.]]></summary></entry><entry><title type="html">Willans‚Äô Formula in APL</title><link href="https://razetime.github.io/blog/2022/12/01/apl-willans.html" rel="alternate" type="text/html" title="Willans‚Äô Formula in APL" /><published>2022-12-01T00:00:00+08:00</published><updated>2022-12-01T00:00:00+08:00</updated><id>https://razetime.github.io/blog/2022/12/01/apl-willans</id><content type="html" xml:base="https://razetime.github.io/blog/2022/12/01/apl-willans.html"><![CDATA[<p>I saw this video from Eric Rowland a few days back, about an exact mathematical formula to derive the nth prime.</p>

<iframe width="560" height="315" src="https://yewtu.be/embed/j5s0h42GfvM" title="yewtube player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<blockquote>
  <p>13:21: It shows that you can use basic arithmetic functions in a programming language
<br />
13:25: and that that programming language is expressive enough to describe the nth prime number.</p>
</blockquote>

<p>This quote instantly reminded me of APL, so I obviously had to try implementing it.</p>

<pre><code class="language-apl">Willans‚Üê{1++/‚åä(√∑‚çµ)*‚ç®‚çµ√∑{+/{‚åä√ó‚ç®2‚óã‚óã‚çµ√∑‚ç®1+!‚çµ-1}‚ç≥‚çµ}¬®‚ç≥2*‚çµ}
</code></pre>

<p>The obvious takeaway from this video is that this is effectively a toy formula that uses several tricks to achieve a ‚Äúclosed
form‚Äù.
I was still very curious about it since it did resemble an APLesque function:</p>
<ul>
  <li>no conditionals</li>
  <li>a good amount of vectorized math</li>
  <li>a little bit of overcomputation, as a treat</li>
</ul>

<p>Actually, there‚Äôs too much overcomputation.</p>
<pre><code class="language-apl">      a‚Üê‚ç≥6
      cmpx 'Willans¬®a' 'pco¬®a'
  Willans¬®a ‚Üí 3.1E¬Ø4 |   0% ‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï
  pco¬®a     ‚Üí 1.1E¬Ø4 | -65% ‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï‚éï
</code></pre>

<p>It fails above <code class="language-plaintext highlighter-rouge">‚çµ=6</code> due to hitting the integer limit (factorials, yay!), but it‚Äôs a nice thing to learn APL‚Äôs basic ideas from.
One can use bignum support like the Python and Mathematica shown in the video, but I don‚Äôt recommend it.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[I saw this video from Eric Rowland a few days back, about an exact mathematical formula to derive the nth prime.]]></summary></entry></feed>