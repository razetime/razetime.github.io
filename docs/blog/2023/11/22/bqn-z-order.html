<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blog | Z orderings in BQN</title>

  <link rel="alternate" type="application/atom+xml" title="Razetime" href="/feed.xml">
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Fenix&display=swap"
    rel="stylesheet"
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css"
  />
  <link rel="stylesheet" href="/style.css" />
  
    <link rel="stylesheet" href="/theme.css" />
  
</head>
<body>
  
  <div class="container"><br>
    <a href="/" style="padding-right: 0.5em;">â† Home</a>
    <a href="/blog">â† Back to Blog</a>
    <br><h2>Z orderings in BQN</h2><p><em>The code for this article can be found on
<a href="https://github.com/razetime/bqnforklift">Github</a>.</em></p>

<p>In my coursework for spatial databases, we came upon the z-order curve, a
space-filling curve that attempts to put multidimesional points into a
single-dimension space with minimal change to the distance between every
point. This does come with its pitfalls but itâ€™s a very interesting
and cheap maneuver for manipulating points.</p>

<p>In BQN, generating the sequence of points is quite simple:</p>

<pre><code class="language-bqn">dâ†âŸ¨0â€¿1,1â€¿1,0â€¿0,1â€¿0âŸ©
ZStepâ†{â¥Šğ•©+âŒœËœdÃ—âŠ‘1+Â¯1âŠ‘ğ•©}
SZCurveâ†{ZStepâŸğ•©d}
</code></pre>

<p><code class="language-plaintext highlighter-rouge">d</code> is the sequence of points representing a single Z. If we arrange four
copies of the current iteration into a Z,
we get the next iteration. The size increases exponentially, so we have
to be wary on larger inputs. It makes for a easy to understand output,
however, good for plotting and understanding how the curve works:</p>

<pre><code class="language-bqn">â€¢PlotÂ´&lt;Ë˜â‰&gt;SZCurve 2
</code></pre>

<p>Z-order curves however may be required on much smaller areas which so not
fit exactly within the space of a square. Bit-weaving solves this problem
by letting us compute the z-ordering for a specific point, allowing us to
get an index without needing to generate a full grid.</p>

<p>For example, assuming that the maximum size of the grid is 7 (3 bits), we
can calculate the z-index of (1,2) like so:</p>

<ol>
  <li>Get the bits: <code class="language-plaintext highlighter-rouge">1 -&gt; 001</code>, <code class="language-plaintext highlighter-rouge">2 -&gt; 010</code></li>
  <li>Interleave the bits, last dimension going first:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 1 0
 0 0 1
------
001001
</code></pre></div>    </div>
  </li>
  <li>Convert that back to an integer: <code class="language-plaintext highlighter-rouge">9</code> is the z-index.</li>
</ol>

<p>A direct bit-based operation makes the usage of z-index very easy to order
points. These are called morton numbers, are they are also very useful for
simply getting unique hashes of points.</p>

<p>The easiest way to interleave bits given bit width is like so:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_iv1â†{2|(âŒŠÃ·âŸœ2)âŸ(âŒ½â†•ğ•—)ğ•©}
</code></pre></div></div>

<p>Bitwise tricks are much faster, however. I will be following
[Sean Andersonâ€™s bit hacks]
(https://graphics.stanford.edu/~seander/bithacks.html#InterleaveTableObvious)
. He shows four different ways to do them, of which you can decide which
is most expressive for you.</p>

<p>First, letâ€™s create a set of functions for us with the
required width. We require bitwise and, or, left shift and right shift.
Shifting operations are not provided by BQN, so we can multiply by two for a
left shift, and divide by two for a right shift.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Baâ€¿Boâ†(&lt;8â€¿8){ğ•¨ğ•Šr:ğ•¨ _r}Â¨âŸ¨â€¢bit._and,â€¢bit._orâŸ©
Blâ†Ã—âŸœ(2âŠ¸â‹†)                                                                      
Brâ†Ã·âŸœ(2âŠ¸â‹†)                                                                      
</code></pre></div></div>

<p>Now, to interleave, we just go through the number bit by bit adding them to an
accumulator. The starting bit width is 3, and the ending width is 6, both fit
inside an 8-bit integer width.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_iv2â†{x ğ•— _ğ•£ y:âŸ¨0âŸ©{ğ•© Bo((x Ba 1 Blğ•¨) Blğ•¨)Bo((y Ba 1 Blğ•¨)Blğ•¨+1)}Â´â†•ğ•—}          
</code></pre></div></div>

<p>and voila! we have out first result:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   1 (3 _iv2)â—‹â¥Š 2
âŸ¨ 9 âŸ©
</code></pre></div></div>

<p>The rest of the methods are lookup tables or use magic numbers, so I will skip
them for brevityâ€™s sake.</p>

<p>Finally, we can do some computations with the transformed data. Since we know
that alterate bits contain alternate integers, we can add coordinates with the
following (for an 8-bit width):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x[i+j] = ((x[i] | 0b10101010) + x[j]) &amp; 0b01010101
x[iâˆ’j] = ((x[i] &amp; 0b01010101) âˆ’ x[j]) &amp; 0b01010101  if i â‰¥ j
</code></pre></div></div>
<p>(Source: Wikipedia.)</p>

<p>Converting this to BQN is not very hard. <code class="language-plaintext highlighter-rouge">0b10101010</code> is 170 and <code class="language-plaintext highlighter-rouge">0b01010101</code>
is 85.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Zpâ†{85 Ba ğ•©+ğ•¨ Bo 170}
Zmâ†{170 Ba ğ•©-Ëœğ•¨ Ba 85}
</code></pre></div></div>

<p>Using these we can now calculate points relative to a given point without
getting rid of its z-order data. This type of calculation is helpful in
constructing quadtrees, for example, since z-ordering properly segments the
points into four exact segments. A binary search tree is usually constructed
for this purpose, but we can simply use <code class="language-plaintext highlighter-rouge">â‹</code> and <code class="language-plaintext highlighter-rouge">â’</code> to perform searches upon
a list of points, converting back and forth between z-order and cartesian
co-ordinates when necessary.</p>

<p>I never completely understood why BQNâ€™s bitwise operations only worked on full
arrays until trying to write this. Even though the bit width is fixed, it helps
that the same conforming rules work correctly in bqn to make rank polymorphism
work.</p>
</div>
</body>
</html>
